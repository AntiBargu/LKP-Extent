// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: lkpProto.proto

#ifndef PROTOBUF_lkpProto_2eproto__INCLUDED
#define PROTOBUF_lkpProto_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace lkpMessage {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_lkpProto_2eproto();
void protobuf_AssignDesc_lkpProto_2eproto();
void protobuf_ShutdownFile_lkpProto_2eproto();

class Command;
class CommandACK;
class File;
class HeartBeat;
class PushACK;
class Return;
class Return_ErrorInfo;

enum File_filetype {
  File_filetype_TESTCASE = 0,
  File_filetype_RESULT = 1,
  File_filetype_File_filetype_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  File_filetype_File_filetype_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool File_filetype_IsValid(int value);
const File_filetype File_filetype_filetype_MIN = File_filetype_TESTCASE;
const File_filetype File_filetype_filetype_MAX = File_filetype_RESULT;
const int File_filetype_filetype_ARRAYSIZE = File_filetype_filetype_MAX + 1;

const ::google::protobuf::EnumDescriptor* File_filetype_descriptor();
inline const ::std::string& File_filetype_Name(File_filetype value) {
  return ::google::protobuf::internal::NameOfEnum(
    File_filetype_descriptor(), value);
}
inline bool File_filetype_Parse(
    const ::std::string& name, File_filetype* value) {
  return ::google::protobuf::internal::ParseNamedEnum<File_filetype>(
    File_filetype_descriptor(), name, value);
}
enum commandID {
  UPDATE = 0,
  RUN = 1,
  RESULT = 2,
  PUSH = 3,
  commandID_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  commandID_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool commandID_IsValid(int value);
const commandID commandID_MIN = UPDATE;
const commandID commandID_MAX = PUSH;
const int commandID_ARRAYSIZE = commandID_MAX + 1;

const ::google::protobuf::EnumDescriptor* commandID_descriptor();
inline const ::std::string& commandID_Name(commandID value) {
  return ::google::protobuf::internal::NameOfEnum(
    commandID_descriptor(), value);
}
inline bool commandID_Parse(
    const ::std::string& name, commandID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<commandID>(
    commandID_descriptor(), name, value);
}
// ===================================================================

class Command : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lkpMessage.Command) */ {
 public:
  Command();
  virtual ~Command();

  Command(const Command& from);

  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Command& default_instance();

  enum TestscriptCase {
    kTestcase = 2,
    kTestcluster = 3,
    TESTSCRIPT_NOT_SET = 0,
  };

  void Swap(Command* other);

  // implements Message ----------------------------------------------

  inline Command* New() const { return New(NULL); }

  Command* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Command& from);
  void MergeFrom(const Command& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Command* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .lkpMessage.commandID command = 1;
  void clear_command();
  static const int kCommandFieldNumber = 1;
  ::lkpMessage::commandID command() const;
  void set_command(::lkpMessage::commandID value);

  // optional string testcase = 2;
  private:
  bool has_testcase() const;
  public:
  void clear_testcase();
  static const int kTestcaseFieldNumber = 2;
  const ::std::string& testcase() const;
  void set_testcase(const ::std::string& value);
  void set_testcase(const char* value);
  void set_testcase(const char* value, size_t size);
  ::std::string* mutable_testcase();
  ::std::string* release_testcase();
  void set_allocated_testcase(::std::string* testcase);

  // optional string testcluster = 3;
  private:
  bool has_testcluster() const;
  public:
  void clear_testcluster();
  static const int kTestclusterFieldNumber = 3;
  const ::std::string& testcluster() const;
  void set_testcluster(const ::std::string& value);
  void set_testcluster(const char* value);
  void set_testcluster(const char* value, size_t size);
  ::std::string* mutable_testcluster();
  ::std::string* release_testcluster();
  void set_allocated_testcluster(::std::string* testcluster);

  // optional uint32 docker_num = 4;
  void clear_docker_num();
  static const int kDockerNumFieldNumber = 4;
  ::google::protobuf::uint32 docker_num() const;
  void set_docker_num(::google::protobuf::uint32 value);

  // optional uint32 tesetcase_len = 5;
  void clear_tesetcase_len();
  static const int kTesetcaseLenFieldNumber = 5;
  ::google::protobuf::uint32 tesetcase_len() const;
  void set_tesetcase_len(::google::protobuf::uint32 value);

  TestscriptCase testscript_case() const;
  // @@protoc_insertion_point(class_scope:lkpMessage.Command)
 private:
  inline void set_has_testcase();
  inline void set_has_testcluster();

  inline bool has_testscript() const;
  void clear_testscript();
  inline void clear_has_testscript();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int command_;
  ::google::protobuf::uint32 docker_num_;
  ::google::protobuf::uint32 tesetcase_len_;
  union TestscriptUnion {
    TestscriptUnion() {}
    ::google::protobuf::internal::ArenaStringPtr testcase_;
    ::google::protobuf::internal::ArenaStringPtr testcluster_;
  } testscript_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_lkpProto_2eproto();
  friend void protobuf_AssignDesc_lkpProto_2eproto();
  friend void protobuf_ShutdownFile_lkpProto_2eproto();

  void InitAsDefaultInstance();
  static Command* default_instance_;
};
// -------------------------------------------------------------------

class File : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lkpMessage.File) */ {
 public:
  File();
  virtual ~File();

  File(const File& from);

  inline File& operator=(const File& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const File& default_instance();

  void Swap(File* other);

  // implements Message ----------------------------------------------

  inline File* New() const { return New(NULL); }

  File* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const File& from);
  void MergeFrom(const File& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(File* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef File_filetype filetype;
  static const filetype TESTCASE =
    File_filetype_TESTCASE;
  static const filetype RESULT =
    File_filetype_RESULT;
  static inline bool filetype_IsValid(int value) {
    return File_filetype_IsValid(value);
  }
  static const filetype filetype_MIN =
    File_filetype_filetype_MIN;
  static const filetype filetype_MAX =
    File_filetype_filetype_MAX;
  static const int filetype_ARRAYSIZE =
    File_filetype_filetype_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  filetype_descriptor() {
    return File_filetype_descriptor();
  }
  static inline const ::std::string& filetype_Name(filetype value) {
    return File_filetype_Name(value);
  }
  static inline bool filetype_Parse(const ::std::string& name,
      filetype* value) {
    return File_filetype_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .lkpMessage.File.filetype file_type = 1;
  void clear_file_type();
  static const int kFileTypeFieldNumber = 1;
  ::lkpMessage::File_filetype file_type() const;
  void set_file_type(::lkpMessage::File_filetype value);

  // optional string file_name = 2;
  void clear_file_name();
  static const int kFileNameFieldNumber = 2;
  const ::std::string& file_name() const;
  void set_file_name(const ::std::string& value);
  void set_file_name(const char* value);
  void set_file_name(const char* value, size_t size);
  ::std::string* mutable_file_name();
  ::std::string* release_file_name();
  void set_allocated_file_name(::std::string* file_name);

  // optional uint32 file_len = 3;
  void clear_file_len();
  static const int kFileLenFieldNumber = 3;
  ::google::protobuf::uint32 file_len() const;
  void set_file_len(::google::protobuf::uint32 value);

  // optional uint32 patch_num = 4;
  void clear_patch_num();
  static const int kPatchNumFieldNumber = 4;
  ::google::protobuf::uint32 patch_num() const;
  void set_patch_num(::google::protobuf::uint32 value);

  // optional bytes content = 5;
  void clear_content();
  static const int kContentFieldNumber = 5;
  const ::std::string& content() const;
  void set_content(const ::std::string& value);
  void set_content(const char* value);
  void set_content(const void* value, size_t size);
  ::std::string* mutable_content();
  ::std::string* release_content();
  void set_allocated_content(::std::string* content);

  // @@protoc_insertion_point(class_scope:lkpMessage.File)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr file_name_;
  int file_type_;
  ::google::protobuf::uint32 file_len_;
  ::google::protobuf::internal::ArenaStringPtr content_;
  ::google::protobuf::uint32 patch_num_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_lkpProto_2eproto();
  friend void protobuf_AssignDesc_lkpProto_2eproto();
  friend void protobuf_ShutdownFile_lkpProto_2eproto();

  void InitAsDefaultInstance();
  static File* default_instance_;
};
// -------------------------------------------------------------------

class CommandACK : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lkpMessage.CommandACK) */ {
 public:
  CommandACK();
  virtual ~CommandACK();

  CommandACK(const CommandACK& from);

  inline CommandACK& operator=(const CommandACK& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandACK& default_instance();

  void Swap(CommandACK* other);

  // implements Message ----------------------------------------------

  inline CommandACK* New() const { return New(NULL); }

  CommandACK* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandACK& from);
  void MergeFrom(const CommandACK& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandACK* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  bool status() const;
  void set_status(bool value);

  // optional .lkpMessage.commandID command = 2;
  void clear_command();
  static const int kCommandFieldNumber = 2;
  ::lkpMessage::commandID command() const;
  void set_command(::lkpMessage::commandID value);

  // optional string ack_message = 3;
  void clear_ack_message();
  static const int kAckMessageFieldNumber = 3;
  const ::std::string& ack_message() const;
  void set_ack_message(const ::std::string& value);
  void set_ack_message(const char* value);
  void set_ack_message(const char* value, size_t size);
  ::std::string* mutable_ack_message();
  ::std::string* release_ack_message();
  void set_allocated_ack_message(::std::string* ack_message);

  // @@protoc_insertion_point(class_scope:lkpMessage.CommandACK)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  bool status_;
  int command_;
  ::google::protobuf::internal::ArenaStringPtr ack_message_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_lkpProto_2eproto();
  friend void protobuf_AssignDesc_lkpProto_2eproto();
  friend void protobuf_ShutdownFile_lkpProto_2eproto();

  void InitAsDefaultInstance();
  static CommandACK* default_instance_;
};
// -------------------------------------------------------------------

class HeartBeat : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lkpMessage.HeartBeat) */ {
 public:
  HeartBeat();
  virtual ~HeartBeat();

  HeartBeat(const HeartBeat& from);

  inline HeartBeat& operator=(const HeartBeat& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartBeat& default_instance();

  void Swap(HeartBeat* other);

  // implements Message ----------------------------------------------

  inline HeartBeat* New() const { return New(NULL); }

  HeartBeat* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HeartBeat& from);
  void MergeFrom(const HeartBeat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HeartBeat* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  bool status() const;
  void set_status(bool value);

  // @@protoc_insertion_point(class_scope:lkpMessage.HeartBeat)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  bool status_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_lkpProto_2eproto();
  friend void protobuf_AssignDesc_lkpProto_2eproto();
  friend void protobuf_ShutdownFile_lkpProto_2eproto();

  void InitAsDefaultInstance();
  static HeartBeat* default_instance_;
};
// -------------------------------------------------------------------

class PushACK : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lkpMessage.PushACK) */ {
 public:
  PushACK();
  virtual ~PushACK();

  PushACK(const PushACK& from);

  inline PushACK& operator=(const PushACK& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PushACK& default_instance();

  void Swap(PushACK* other);

  // implements Message ----------------------------------------------

  inline PushACK* New() const { return New(NULL); }

  PushACK* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PushACK& from);
  void MergeFrom(const PushACK& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PushACK* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  bool status() const;
  void set_status(bool value);

  // optional string ack_message = 2;
  void clear_ack_message();
  static const int kAckMessageFieldNumber = 2;
  const ::std::string& ack_message() const;
  void set_ack_message(const ::std::string& value);
  void set_ack_message(const char* value);
  void set_ack_message(const char* value, size_t size);
  ::std::string* mutable_ack_message();
  ::std::string* release_ack_message();
  void set_allocated_ack_message(::std::string* ack_message);

  // @@protoc_insertion_point(class_scope:lkpMessage.PushACK)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr ack_message_;
  bool status_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_lkpProto_2eproto();
  friend void protobuf_AssignDesc_lkpProto_2eproto();
  friend void protobuf_ShutdownFile_lkpProto_2eproto();

  void InitAsDefaultInstance();
  static PushACK* default_instance_;
};
// -------------------------------------------------------------------

class Return_ErrorInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lkpMessage.Return.ErrorInfo) */ {
 public:
  Return_ErrorInfo();
  virtual ~Return_ErrorInfo();

  Return_ErrorInfo(const Return_ErrorInfo& from);

  inline Return_ErrorInfo& operator=(const Return_ErrorInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Return_ErrorInfo& default_instance();

  void Swap(Return_ErrorInfo* other);

  // implements Message ----------------------------------------------

  inline Return_ErrorInfo* New() const { return New(NULL); }

  Return_ErrorInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Return_ErrorInfo& from);
  void MergeFrom(const Return_ErrorInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Return_ErrorInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 node_id = 1;
  void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  ::google::protobuf::uint32 node_id() const;
  void set_node_id(::google::protobuf::uint32 value);

  // optional string error_msg = 2;
  void clear_error_msg();
  static const int kErrorMsgFieldNumber = 2;
  const ::std::string& error_msg() const;
  void set_error_msg(const ::std::string& value);
  void set_error_msg(const char* value);
  void set_error_msg(const char* value, size_t size);
  ::std::string* mutable_error_msg();
  ::std::string* release_error_msg();
  void set_allocated_error_msg(::std::string* error_msg);

  // @@protoc_insertion_point(class_scope:lkpMessage.Return.ErrorInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr error_msg_;
  ::google::protobuf::uint32 node_id_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_lkpProto_2eproto();
  friend void protobuf_AssignDesc_lkpProto_2eproto();
  friend void protobuf_ShutdownFile_lkpProto_2eproto();

  void InitAsDefaultInstance();
  static Return_ErrorInfo* default_instance_;
};
// -------------------------------------------------------------------

class Return : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lkpMessage.Return) */ {
 public:
  Return();
  virtual ~Return();

  Return(const Return& from);

  inline Return& operator=(const Return& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Return& default_instance();

  void Swap(Return* other);

  // implements Message ----------------------------------------------

  inline Return* New() const { return New(NULL); }

  Return* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Return& from);
  void MergeFrom(const Return& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Return* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Return_ErrorInfo ErrorInfo;

  // accessors -------------------------------------------------------

  // optional uint32 clinet_num = 1;
  void clear_clinet_num();
  static const int kClinetNumFieldNumber = 1;
  ::google::protobuf::uint32 clinet_num() const;
  void set_clinet_num(::google::protobuf::uint32 value);

  // optional uint32 client_ok_num = 2;
  void clear_client_ok_num();
  static const int kClientOkNumFieldNumber = 2;
  ::google::protobuf::uint32 client_ok_num() const;
  void set_client_ok_num(::google::protobuf::uint32 value);

  // optional .lkpMessage.commandID command = 3;
  void clear_command();
  static const int kCommandFieldNumber = 3;
  ::lkpMessage::commandID command() const;
  void set_command(::lkpMessage::commandID value);

  // repeated .lkpMessage.Return.ErrorInfo error_info = 4;
  int error_info_size() const;
  void clear_error_info();
  static const int kErrorInfoFieldNumber = 4;
  const ::lkpMessage::Return_ErrorInfo& error_info(int index) const;
  ::lkpMessage::Return_ErrorInfo* mutable_error_info(int index);
  ::lkpMessage::Return_ErrorInfo* add_error_info();
  ::google::protobuf::RepeatedPtrField< ::lkpMessage::Return_ErrorInfo >*
      mutable_error_info();
  const ::google::protobuf::RepeatedPtrField< ::lkpMessage::Return_ErrorInfo >&
      error_info() const;

  // @@protoc_insertion_point(class_scope:lkpMessage.Return)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::uint32 clinet_num_;
  ::google::protobuf::uint32 client_ok_num_;
  ::google::protobuf::RepeatedPtrField< ::lkpMessage::Return_ErrorInfo > error_info_;
  int command_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_lkpProto_2eproto();
  friend void protobuf_AssignDesc_lkpProto_2eproto();
  friend void protobuf_ShutdownFile_lkpProto_2eproto();

  void InitAsDefaultInstance();
  static Return* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Command

// optional .lkpMessage.commandID command = 1;
inline void Command::clear_command() {
  command_ = 0;
}
inline ::lkpMessage::commandID Command::command() const {
  // @@protoc_insertion_point(field_get:lkpMessage.Command.command)
  return static_cast< ::lkpMessage::commandID >(command_);
}
inline void Command::set_command(::lkpMessage::commandID value) {
  
  command_ = value;
  // @@protoc_insertion_point(field_set:lkpMessage.Command.command)
}

// optional string testcase = 2;
inline bool Command::has_testcase() const {
  return testscript_case() == kTestcase;
}
inline void Command::set_has_testcase() {
  _oneof_case_[0] = kTestcase;
}
inline void Command::clear_testcase() {
  if (has_testcase()) {
    testscript_.testcase_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_testscript();
  }
}
inline const ::std::string& Command::testcase() const {
  // @@protoc_insertion_point(field_get:lkpMessage.Command.testcase)
  if (has_testcase()) {
    return testscript_.testcase_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void Command::set_testcase(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:lkpMessage.Command.testcase)
  if (!has_testcase()) {
    clear_testscript();
    set_has_testcase();
    testscript_.testcase_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  testscript_.testcase_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:lkpMessage.Command.testcase)
}
inline void Command::set_testcase(const char* value) {
  if (!has_testcase()) {
    clear_testscript();
    set_has_testcase();
    testscript_.testcase_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  testscript_.testcase_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:lkpMessage.Command.testcase)
}
inline void Command::set_testcase(const char* value, size_t size) {
  if (!has_testcase()) {
    clear_testscript();
    set_has_testcase();
    testscript_.testcase_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  testscript_.testcase_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:lkpMessage.Command.testcase)
}
inline ::std::string* Command::mutable_testcase() {
  if (!has_testcase()) {
    clear_testscript();
    set_has_testcase();
    testscript_.testcase_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:lkpMessage.Command.testcase)
  return testscript_.testcase_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Command::release_testcase() {
  // @@protoc_insertion_point(field_release:lkpMessage.Command.testcase)
  if (has_testcase()) {
    clear_has_testscript();
    return testscript_.testcase_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void Command::set_allocated_testcase(::std::string* testcase) {
  if (!has_testcase()) {
    testscript_.testcase_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_testscript();
  if (testcase != NULL) {
    set_has_testcase();
    testscript_.testcase_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        testcase);
  }
  // @@protoc_insertion_point(field_set_allocated:lkpMessage.Command.testcase)
}

// optional string testcluster = 3;
inline bool Command::has_testcluster() const {
  return testscript_case() == kTestcluster;
}
inline void Command::set_has_testcluster() {
  _oneof_case_[0] = kTestcluster;
}
inline void Command::clear_testcluster() {
  if (has_testcluster()) {
    testscript_.testcluster_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_testscript();
  }
}
inline const ::std::string& Command::testcluster() const {
  // @@protoc_insertion_point(field_get:lkpMessage.Command.testcluster)
  if (has_testcluster()) {
    return testscript_.testcluster_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void Command::set_testcluster(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:lkpMessage.Command.testcluster)
  if (!has_testcluster()) {
    clear_testscript();
    set_has_testcluster();
    testscript_.testcluster_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  testscript_.testcluster_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:lkpMessage.Command.testcluster)
}
inline void Command::set_testcluster(const char* value) {
  if (!has_testcluster()) {
    clear_testscript();
    set_has_testcluster();
    testscript_.testcluster_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  testscript_.testcluster_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:lkpMessage.Command.testcluster)
}
inline void Command::set_testcluster(const char* value, size_t size) {
  if (!has_testcluster()) {
    clear_testscript();
    set_has_testcluster();
    testscript_.testcluster_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  testscript_.testcluster_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:lkpMessage.Command.testcluster)
}
inline ::std::string* Command::mutable_testcluster() {
  if (!has_testcluster()) {
    clear_testscript();
    set_has_testcluster();
    testscript_.testcluster_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:lkpMessage.Command.testcluster)
  return testscript_.testcluster_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Command::release_testcluster() {
  // @@protoc_insertion_point(field_release:lkpMessage.Command.testcluster)
  if (has_testcluster()) {
    clear_has_testscript();
    return testscript_.testcluster_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void Command::set_allocated_testcluster(::std::string* testcluster) {
  if (!has_testcluster()) {
    testscript_.testcluster_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_testscript();
  if (testcluster != NULL) {
    set_has_testcluster();
    testscript_.testcluster_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        testcluster);
  }
  // @@protoc_insertion_point(field_set_allocated:lkpMessage.Command.testcluster)
}

// optional uint32 docker_num = 4;
inline void Command::clear_docker_num() {
  docker_num_ = 0u;
}
inline ::google::protobuf::uint32 Command::docker_num() const {
  // @@protoc_insertion_point(field_get:lkpMessage.Command.docker_num)
  return docker_num_;
}
inline void Command::set_docker_num(::google::protobuf::uint32 value) {
  
  docker_num_ = value;
  // @@protoc_insertion_point(field_set:lkpMessage.Command.docker_num)
}

// optional uint32 tesetcase_len = 5;
inline void Command::clear_tesetcase_len() {
  tesetcase_len_ = 0u;
}
inline ::google::protobuf::uint32 Command::tesetcase_len() const {
  // @@protoc_insertion_point(field_get:lkpMessage.Command.tesetcase_len)
  return tesetcase_len_;
}
inline void Command::set_tesetcase_len(::google::protobuf::uint32 value) {
  
  tesetcase_len_ = value;
  // @@protoc_insertion_point(field_set:lkpMessage.Command.tesetcase_len)
}

inline bool Command::has_testscript() const {
  return testscript_case() != TESTSCRIPT_NOT_SET;
}
inline void Command::clear_has_testscript() {
  _oneof_case_[0] = TESTSCRIPT_NOT_SET;
}
inline Command::TestscriptCase Command::testscript_case() const {
  return Command::TestscriptCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// File

// optional .lkpMessage.File.filetype file_type = 1;
inline void File::clear_file_type() {
  file_type_ = 0;
}
inline ::lkpMessage::File_filetype File::file_type() const {
  // @@protoc_insertion_point(field_get:lkpMessage.File.file_type)
  return static_cast< ::lkpMessage::File_filetype >(file_type_);
}
inline void File::set_file_type(::lkpMessage::File_filetype value) {
  
  file_type_ = value;
  // @@protoc_insertion_point(field_set:lkpMessage.File.file_type)
}

// optional string file_name = 2;
inline void File::clear_file_name() {
  file_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& File::file_name() const {
  // @@protoc_insertion_point(field_get:lkpMessage.File.file_name)
  return file_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void File::set_file_name(const ::std::string& value) {
  
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:lkpMessage.File.file_name)
}
inline void File::set_file_name(const char* value) {
  
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:lkpMessage.File.file_name)
}
inline void File::set_file_name(const char* value, size_t size) {
  
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:lkpMessage.File.file_name)
}
inline ::std::string* File::mutable_file_name() {
  
  // @@protoc_insertion_point(field_mutable:lkpMessage.File.file_name)
  return file_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* File::release_file_name() {
  // @@protoc_insertion_point(field_release:lkpMessage.File.file_name)
  
  return file_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void File::set_allocated_file_name(::std::string* file_name) {
  if (file_name != NULL) {
    
  } else {
    
  }
  file_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file_name);
  // @@protoc_insertion_point(field_set_allocated:lkpMessage.File.file_name)
}

// optional uint32 file_len = 3;
inline void File::clear_file_len() {
  file_len_ = 0u;
}
inline ::google::protobuf::uint32 File::file_len() const {
  // @@protoc_insertion_point(field_get:lkpMessage.File.file_len)
  return file_len_;
}
inline void File::set_file_len(::google::protobuf::uint32 value) {
  
  file_len_ = value;
  // @@protoc_insertion_point(field_set:lkpMessage.File.file_len)
}

// optional uint32 patch_num = 4;
inline void File::clear_patch_num() {
  patch_num_ = 0u;
}
inline ::google::protobuf::uint32 File::patch_num() const {
  // @@protoc_insertion_point(field_get:lkpMessage.File.patch_num)
  return patch_num_;
}
inline void File::set_patch_num(::google::protobuf::uint32 value) {
  
  patch_num_ = value;
  // @@protoc_insertion_point(field_set:lkpMessage.File.patch_num)
}

// optional bytes content = 5;
inline void File::clear_content() {
  content_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& File::content() const {
  // @@protoc_insertion_point(field_get:lkpMessage.File.content)
  return content_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void File::set_content(const ::std::string& value) {
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:lkpMessage.File.content)
}
inline void File::set_content(const char* value) {
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:lkpMessage.File.content)
}
inline void File::set_content(const void* value, size_t size) {
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:lkpMessage.File.content)
}
inline ::std::string* File::mutable_content() {
  
  // @@protoc_insertion_point(field_mutable:lkpMessage.File.content)
  return content_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* File::release_content() {
  // @@protoc_insertion_point(field_release:lkpMessage.File.content)
  
  return content_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void File::set_allocated_content(::std::string* content) {
  if (content != NULL) {
    
  } else {
    
  }
  content_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), content);
  // @@protoc_insertion_point(field_set_allocated:lkpMessage.File.content)
}

// -------------------------------------------------------------------

// CommandACK

// optional bool status = 1;
inline void CommandACK::clear_status() {
  status_ = false;
}
inline bool CommandACK::status() const {
  // @@protoc_insertion_point(field_get:lkpMessage.CommandACK.status)
  return status_;
}
inline void CommandACK::set_status(bool value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:lkpMessage.CommandACK.status)
}

// optional .lkpMessage.commandID command = 2;
inline void CommandACK::clear_command() {
  command_ = 0;
}
inline ::lkpMessage::commandID CommandACK::command() const {
  // @@protoc_insertion_point(field_get:lkpMessage.CommandACK.command)
  return static_cast< ::lkpMessage::commandID >(command_);
}
inline void CommandACK::set_command(::lkpMessage::commandID value) {
  
  command_ = value;
  // @@protoc_insertion_point(field_set:lkpMessage.CommandACK.command)
}

// optional string ack_message = 3;
inline void CommandACK::clear_ack_message() {
  ack_message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CommandACK::ack_message() const {
  // @@protoc_insertion_point(field_get:lkpMessage.CommandACK.ack_message)
  return ack_message_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CommandACK::set_ack_message(const ::std::string& value) {
  
  ack_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:lkpMessage.CommandACK.ack_message)
}
inline void CommandACK::set_ack_message(const char* value) {
  
  ack_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:lkpMessage.CommandACK.ack_message)
}
inline void CommandACK::set_ack_message(const char* value, size_t size) {
  
  ack_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:lkpMessage.CommandACK.ack_message)
}
inline ::std::string* CommandACK::mutable_ack_message() {
  
  // @@protoc_insertion_point(field_mutable:lkpMessage.CommandACK.ack_message)
  return ack_message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CommandACK::release_ack_message() {
  // @@protoc_insertion_point(field_release:lkpMessage.CommandACK.ack_message)
  
  return ack_message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CommandACK::set_allocated_ack_message(::std::string* ack_message) {
  if (ack_message != NULL) {
    
  } else {
    
  }
  ack_message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ack_message);
  // @@protoc_insertion_point(field_set_allocated:lkpMessage.CommandACK.ack_message)
}

// -------------------------------------------------------------------

// HeartBeat

// optional bool status = 1;
inline void HeartBeat::clear_status() {
  status_ = false;
}
inline bool HeartBeat::status() const {
  // @@protoc_insertion_point(field_get:lkpMessage.HeartBeat.status)
  return status_;
}
inline void HeartBeat::set_status(bool value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:lkpMessage.HeartBeat.status)
}

// -------------------------------------------------------------------

// PushACK

// optional bool status = 1;
inline void PushACK::clear_status() {
  status_ = false;
}
inline bool PushACK::status() const {
  // @@protoc_insertion_point(field_get:lkpMessage.PushACK.status)
  return status_;
}
inline void PushACK::set_status(bool value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:lkpMessage.PushACK.status)
}

// optional string ack_message = 2;
inline void PushACK::clear_ack_message() {
  ack_message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PushACK::ack_message() const {
  // @@protoc_insertion_point(field_get:lkpMessage.PushACK.ack_message)
  return ack_message_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PushACK::set_ack_message(const ::std::string& value) {
  
  ack_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:lkpMessage.PushACK.ack_message)
}
inline void PushACK::set_ack_message(const char* value) {
  
  ack_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:lkpMessage.PushACK.ack_message)
}
inline void PushACK::set_ack_message(const char* value, size_t size) {
  
  ack_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:lkpMessage.PushACK.ack_message)
}
inline ::std::string* PushACK::mutable_ack_message() {
  
  // @@protoc_insertion_point(field_mutable:lkpMessage.PushACK.ack_message)
  return ack_message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PushACK::release_ack_message() {
  // @@protoc_insertion_point(field_release:lkpMessage.PushACK.ack_message)
  
  return ack_message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PushACK::set_allocated_ack_message(::std::string* ack_message) {
  if (ack_message != NULL) {
    
  } else {
    
  }
  ack_message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ack_message);
  // @@protoc_insertion_point(field_set_allocated:lkpMessage.PushACK.ack_message)
}

// -------------------------------------------------------------------

// Return_ErrorInfo

// optional uint32 node_id = 1;
inline void Return_ErrorInfo::clear_node_id() {
  node_id_ = 0u;
}
inline ::google::protobuf::uint32 Return_ErrorInfo::node_id() const {
  // @@protoc_insertion_point(field_get:lkpMessage.Return.ErrorInfo.node_id)
  return node_id_;
}
inline void Return_ErrorInfo::set_node_id(::google::protobuf::uint32 value) {
  
  node_id_ = value;
  // @@protoc_insertion_point(field_set:lkpMessage.Return.ErrorInfo.node_id)
}

// optional string error_msg = 2;
inline void Return_ErrorInfo::clear_error_msg() {
  error_msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Return_ErrorInfo::error_msg() const {
  // @@protoc_insertion_point(field_get:lkpMessage.Return.ErrorInfo.error_msg)
  return error_msg_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Return_ErrorInfo::set_error_msg(const ::std::string& value) {
  
  error_msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:lkpMessage.Return.ErrorInfo.error_msg)
}
inline void Return_ErrorInfo::set_error_msg(const char* value) {
  
  error_msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:lkpMessage.Return.ErrorInfo.error_msg)
}
inline void Return_ErrorInfo::set_error_msg(const char* value, size_t size) {
  
  error_msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:lkpMessage.Return.ErrorInfo.error_msg)
}
inline ::std::string* Return_ErrorInfo::mutable_error_msg() {
  
  // @@protoc_insertion_point(field_mutable:lkpMessage.Return.ErrorInfo.error_msg)
  return error_msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Return_ErrorInfo::release_error_msg() {
  // @@protoc_insertion_point(field_release:lkpMessage.Return.ErrorInfo.error_msg)
  
  return error_msg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Return_ErrorInfo::set_allocated_error_msg(::std::string* error_msg) {
  if (error_msg != NULL) {
    
  } else {
    
  }
  error_msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_msg);
  // @@protoc_insertion_point(field_set_allocated:lkpMessage.Return.ErrorInfo.error_msg)
}

// -------------------------------------------------------------------

// Return

// optional uint32 clinet_num = 1;
inline void Return::clear_clinet_num() {
  clinet_num_ = 0u;
}
inline ::google::protobuf::uint32 Return::clinet_num() const {
  // @@protoc_insertion_point(field_get:lkpMessage.Return.clinet_num)
  return clinet_num_;
}
inline void Return::set_clinet_num(::google::protobuf::uint32 value) {
  
  clinet_num_ = value;
  // @@protoc_insertion_point(field_set:lkpMessage.Return.clinet_num)
}

// optional uint32 client_ok_num = 2;
inline void Return::clear_client_ok_num() {
  client_ok_num_ = 0u;
}
inline ::google::protobuf::uint32 Return::client_ok_num() const {
  // @@protoc_insertion_point(field_get:lkpMessage.Return.client_ok_num)
  return client_ok_num_;
}
inline void Return::set_client_ok_num(::google::protobuf::uint32 value) {
  
  client_ok_num_ = value;
  // @@protoc_insertion_point(field_set:lkpMessage.Return.client_ok_num)
}

// optional .lkpMessage.commandID command = 3;
inline void Return::clear_command() {
  command_ = 0;
}
inline ::lkpMessage::commandID Return::command() const {
  // @@protoc_insertion_point(field_get:lkpMessage.Return.command)
  return static_cast< ::lkpMessage::commandID >(command_);
}
inline void Return::set_command(::lkpMessage::commandID value) {
  
  command_ = value;
  // @@protoc_insertion_point(field_set:lkpMessage.Return.command)
}

// repeated .lkpMessage.Return.ErrorInfo error_info = 4;
inline int Return::error_info_size() const {
  return error_info_.size();
}
inline void Return::clear_error_info() {
  error_info_.Clear();
}
inline const ::lkpMessage::Return_ErrorInfo& Return::error_info(int index) const {
  // @@protoc_insertion_point(field_get:lkpMessage.Return.error_info)
  return error_info_.Get(index);
}
inline ::lkpMessage::Return_ErrorInfo* Return::mutable_error_info(int index) {
  // @@protoc_insertion_point(field_mutable:lkpMessage.Return.error_info)
  return error_info_.Mutable(index);
}
inline ::lkpMessage::Return_ErrorInfo* Return::add_error_info() {
  // @@protoc_insertion_point(field_add:lkpMessage.Return.error_info)
  return error_info_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::lkpMessage::Return_ErrorInfo >*
Return::mutable_error_info() {
  // @@protoc_insertion_point(field_mutable_list:lkpMessage.Return.error_info)
  return &error_info_;
}
inline const ::google::protobuf::RepeatedPtrField< ::lkpMessage::Return_ErrorInfo >&
Return::error_info() const {
  // @@protoc_insertion_point(field_list:lkpMessage.Return.error_info)
  return error_info_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace lkpMessage

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::lkpMessage::File_filetype> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::lkpMessage::File_filetype>() {
  return ::lkpMessage::File_filetype_descriptor();
}
template <> struct is_proto_enum< ::lkpMessage::commandID> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::lkpMessage::commandID>() {
  return ::lkpMessage::commandID_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_lkpProto_2eproto__INCLUDED
