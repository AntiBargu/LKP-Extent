// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: lkpProto.proto

#ifndef PROTOBUF_lkpProto_2eproto__INCLUDED
#define PROTOBUF_lkpProto_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace lkpMessage {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_lkpProto_2eproto();
void protobuf_AssignDesc_lkpProto_2eproto();
void protobuf_ShutdownFile_lkpProto_2eproto();

class Command;
class CommandACK;
class File;
class HeartBeat;
class PushACK;
class Return;
class Return_NodeInfo;

enum File_filetype {
  File_filetype_TESTCASE = 0,
  File_filetype_RESULT = 1,
  File_filetype_END = 2,
  File_filetype_File_filetype_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  File_filetype_File_filetype_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool File_filetype_IsValid(int value);
const File_filetype File_filetype_filetype_MIN = File_filetype_TESTCASE;
const File_filetype File_filetype_filetype_MAX = File_filetype_END;
const int File_filetype_filetype_ARRAYSIZE = File_filetype_filetype_MAX + 1;

const ::google::protobuf::EnumDescriptor* File_filetype_descriptor();
inline const ::std::string& File_filetype_Name(File_filetype value) {
  return ::google::protobuf::internal::NameOfEnum(
    File_filetype_descriptor(), value);
}
inline bool File_filetype_Parse(
    const ::std::string& name, File_filetype* value) {
  return ::google::protobuf::internal::ParseNamedEnum<File_filetype>(
    File_filetype_descriptor(), name, value);
}
enum commandID {
  UPDATE = 0,
  RUN = 1,
  RESULT = 2,
  PUSH = 3,
  LIST = 4,
  commandID_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  commandID_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool commandID_IsValid(int value);
const commandID commandID_MIN = UPDATE;
const commandID commandID_MAX = LIST;
const int commandID_ARRAYSIZE = commandID_MAX + 1;

const ::google::protobuf::EnumDescriptor* commandID_descriptor();
inline const ::std::string& commandID_Name(commandID value) {
  return ::google::protobuf::internal::NameOfEnum(
    commandID_descriptor(), value);
}
inline bool commandID_Parse(
    const ::std::string& name, commandID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<commandID>(
    commandID_descriptor(), name, value);
}
// ===================================================================

class Command : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lkpMessage.Command) */ {
 public:
  Command();
  virtual ~Command();

  Command(const Command& from);

  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Command& default_instance();

  void Swap(Command* other);

  // implements Message ----------------------------------------------

  inline Command* New() const { return New(NULL); }

  Command* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Command& from);
  void MergeFrom(const Command& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Command* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .lkpMessage.commandID command = 1;
  void clear_command();
  static const int kCommandFieldNumber = 1;
  ::lkpMessage::commandID command() const;
  void set_command(::lkpMessage::commandID value);

  // optional bool send_to_all = 2;
  void clear_send_to_all();
  static const int kSendToAllFieldNumber = 2;
  bool send_to_all() const;
  void set_send_to_all(bool value);

  // optional string testcase = 3;
  void clear_testcase();
  static const int kTestcaseFieldNumber = 3;
  const ::std::string& testcase() const;
  void set_testcase(const ::std::string& value);
  void set_testcase(const char* value);
  void set_testcase(const char* value, size_t size);
  ::std::string* mutable_testcase();
  ::std::string* release_testcase();
  void set_allocated_testcase(::std::string* testcase);

  // optional uint32 docker_num = 4;
  void clear_docker_num();
  static const int kDockerNumFieldNumber = 4;
  ::google::protobuf::uint32 docker_num() const;
  void set_docker_num(::google::protobuf::uint32 value);

  // optional uint32 tesetcase_len = 5;
  void clear_tesetcase_len();
  static const int kTesetcaseLenFieldNumber = 5;
  ::google::protobuf::uint32 tesetcase_len() const;
  void set_tesetcase_len(::google::protobuf::uint32 value);

  // optional uint32 node_id = 6;
  void clear_node_id();
  static const int kNodeIdFieldNumber = 6;
  ::google::protobuf::uint32 node_id() const;
  void set_node_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:lkpMessage.Command)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int command_;
  bool send_to_all_;
  ::google::protobuf::internal::ArenaStringPtr testcase_;
  ::google::protobuf::uint32 docker_num_;
  ::google::protobuf::uint32 tesetcase_len_;
  ::google::protobuf::uint32 node_id_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_lkpProto_2eproto();
  friend void protobuf_AssignDesc_lkpProto_2eproto();
  friend void protobuf_ShutdownFile_lkpProto_2eproto();

  void InitAsDefaultInstance();
  static Command* default_instance_;
};
// -------------------------------------------------------------------

class File : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lkpMessage.File) */ {
 public:
  File();
  virtual ~File();

  File(const File& from);

  inline File& operator=(const File& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const File& default_instance();

  void Swap(File* other);

  // implements Message ----------------------------------------------

  inline File* New() const { return New(NULL); }

  File* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const File& from);
  void MergeFrom(const File& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(File* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef File_filetype filetype;
  static const filetype TESTCASE =
    File_filetype_TESTCASE;
  static const filetype RESULT =
    File_filetype_RESULT;
  static const filetype END =
    File_filetype_END;
  static inline bool filetype_IsValid(int value) {
    return File_filetype_IsValid(value);
  }
  static const filetype filetype_MIN =
    File_filetype_filetype_MIN;
  static const filetype filetype_MAX =
    File_filetype_filetype_MAX;
  static const int filetype_ARRAYSIZE =
    File_filetype_filetype_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  filetype_descriptor() {
    return File_filetype_descriptor();
  }
  static inline const ::std::string& filetype_Name(filetype value) {
    return File_filetype_Name(value);
  }
  static inline bool filetype_Parse(const ::std::string& name,
      filetype* value) {
    return File_filetype_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .lkpMessage.File.filetype file_type = 1;
  void clear_file_type();
  static const int kFileTypeFieldNumber = 1;
  ::lkpMessage::File_filetype file_type() const;
  void set_file_type(::lkpMessage::File_filetype value);

  // optional string file_name = 2;
  void clear_file_name();
  static const int kFileNameFieldNumber = 2;
  const ::std::string& file_name() const;
  void set_file_name(const ::std::string& value);
  void set_file_name(const char* value);
  void set_file_name(const char* value, size_t size);
  ::std::string* mutable_file_name();
  ::std::string* release_file_name();
  void set_allocated_file_name(::std::string* file_name);

  // optional uint32 patch_len = 3;
  void clear_patch_len();
  static const int kPatchLenFieldNumber = 3;
  ::google::protobuf::uint32 patch_len() const;
  void set_patch_len(::google::protobuf::uint32 value);

  // optional uint32 file_size = 4;
  void clear_file_size();
  static const int kFileSizeFieldNumber = 4;
  ::google::protobuf::uint32 file_size() const;
  void set_file_size(::google::protobuf::uint32 value);

  // optional bool first_patch = 5;
  void clear_first_patch();
  static const int kFirstPatchFieldNumber = 5;
  bool first_patch() const;
  void set_first_patch(bool value);

  // optional bytes content = 6;
  void clear_content();
  static const int kContentFieldNumber = 6;
  const ::std::string& content() const;
  void set_content(const ::std::string& value);
  void set_content(const char* value);
  void set_content(const void* value, size_t size);
  ::std::string* mutable_content();
  ::std::string* release_content();
  void set_allocated_content(::std::string* content);

  // optional uint32 node_id = 7;
  void clear_node_id();
  static const int kNodeIdFieldNumber = 7;
  ::google::protobuf::uint32 node_id() const;
  void set_node_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:lkpMessage.File)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr file_name_;
  int file_type_;
  ::google::protobuf::uint32 patch_len_;
  ::google::protobuf::uint32 file_size_;
  bool first_patch_;
  ::google::protobuf::internal::ArenaStringPtr content_;
  ::google::protobuf::uint32 node_id_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_lkpProto_2eproto();
  friend void protobuf_AssignDesc_lkpProto_2eproto();
  friend void protobuf_ShutdownFile_lkpProto_2eproto();

  void InitAsDefaultInstance();
  static File* default_instance_;
};
// -------------------------------------------------------------------

class CommandACK : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lkpMessage.CommandACK) */ {
 public:
  CommandACK();
  virtual ~CommandACK();

  CommandACK(const CommandACK& from);

  inline CommandACK& operator=(const CommandACK& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandACK& default_instance();

  void Swap(CommandACK* other);

  // implements Message ----------------------------------------------

  inline CommandACK* New() const { return New(NULL); }

  CommandACK* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandACK& from);
  void MergeFrom(const CommandACK& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandACK* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  bool status() const;
  void set_status(bool value);

  // optional .lkpMessage.commandID command = 2;
  void clear_command();
  static const int kCommandFieldNumber = 2;
  ::lkpMessage::commandID command() const;
  void set_command(::lkpMessage::commandID value);

  // optional string ack_message = 3;
  void clear_ack_message();
  static const int kAckMessageFieldNumber = 3;
  const ::std::string& ack_message() const;
  void set_ack_message(const ::std::string& value);
  void set_ack_message(const char* value);
  void set_ack_message(const char* value, size_t size);
  ::std::string* mutable_ack_message();
  ::std::string* release_ack_message();
  void set_allocated_ack_message(::std::string* ack_message);

  // @@protoc_insertion_point(class_scope:lkpMessage.CommandACK)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  bool status_;
  int command_;
  ::google::protobuf::internal::ArenaStringPtr ack_message_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_lkpProto_2eproto();
  friend void protobuf_AssignDesc_lkpProto_2eproto();
  friend void protobuf_ShutdownFile_lkpProto_2eproto();

  void InitAsDefaultInstance();
  static CommandACK* default_instance_;
};
// -------------------------------------------------------------------

class HeartBeat : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lkpMessage.HeartBeat) */ {
 public:
  HeartBeat();
  virtual ~HeartBeat();

  HeartBeat(const HeartBeat& from);

  inline HeartBeat& operator=(const HeartBeat& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartBeat& default_instance();

  void Swap(HeartBeat* other);

  // implements Message ----------------------------------------------

  inline HeartBeat* New() const { return New(NULL); }

  HeartBeat* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HeartBeat& from);
  void MergeFrom(const HeartBeat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HeartBeat* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  bool status() const;
  void set_status(bool value);

  // @@protoc_insertion_point(class_scope:lkpMessage.HeartBeat)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  bool status_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_lkpProto_2eproto();
  friend void protobuf_AssignDesc_lkpProto_2eproto();
  friend void protobuf_ShutdownFile_lkpProto_2eproto();

  void InitAsDefaultInstance();
  static HeartBeat* default_instance_;
};
// -------------------------------------------------------------------

class PushACK : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lkpMessage.PushACK) */ {
 public:
  PushACK();
  virtual ~PushACK();

  PushACK(const PushACK& from);

  inline PushACK& operator=(const PushACK& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PushACK& default_instance();

  void Swap(PushACK* other);

  // implements Message ----------------------------------------------

  inline PushACK* New() const { return New(NULL); }

  PushACK* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PushACK& from);
  void MergeFrom(const PushACK& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PushACK* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  bool status() const;
  void set_status(bool value);

  // optional string ack_message = 2;
  void clear_ack_message();
  static const int kAckMessageFieldNumber = 2;
  const ::std::string& ack_message() const;
  void set_ack_message(const ::std::string& value);
  void set_ack_message(const char* value);
  void set_ack_message(const char* value, size_t size);
  ::std::string* mutable_ack_message();
  ::std::string* release_ack_message();
  void set_allocated_ack_message(::std::string* ack_message);

  // optional uint32 node_id = 3;
  void clear_node_id();
  static const int kNodeIdFieldNumber = 3;
  ::google::protobuf::uint32 node_id() const;
  void set_node_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:lkpMessage.PushACK)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr ack_message_;
  bool status_;
  ::google::protobuf::uint32 node_id_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_lkpProto_2eproto();
  friend void protobuf_AssignDesc_lkpProto_2eproto();
  friend void protobuf_ShutdownFile_lkpProto_2eproto();

  void InitAsDefaultInstance();
  static PushACK* default_instance_;
};
// -------------------------------------------------------------------

class Return_NodeInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lkpMessage.Return.NodeInfo) */ {
 public:
  Return_NodeInfo();
  virtual ~Return_NodeInfo();

  Return_NodeInfo(const Return_NodeInfo& from);

  inline Return_NodeInfo& operator=(const Return_NodeInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Return_NodeInfo& default_instance();

  void Swap(Return_NodeInfo* other);

  // implements Message ----------------------------------------------

  inline Return_NodeInfo* New() const { return New(NULL); }

  Return_NodeInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Return_NodeInfo& from);
  void MergeFrom(const Return_NodeInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Return_NodeInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 node_id = 1;
  void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  ::google::protobuf::uint32 node_id() const;
  void set_node_id(::google::protobuf::uint32 value);

  // optional string node_msg = 2;
  void clear_node_msg();
  static const int kNodeMsgFieldNumber = 2;
  const ::std::string& node_msg() const;
  void set_node_msg(const ::std::string& value);
  void set_node_msg(const char* value);
  void set_node_msg(const char* value, size_t size);
  ::std::string* mutable_node_msg();
  ::std::string* release_node_msg();
  void set_allocated_node_msg(::std::string* node_msg);

  // @@protoc_insertion_point(class_scope:lkpMessage.Return.NodeInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr node_msg_;
  ::google::protobuf::uint32 node_id_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_lkpProto_2eproto();
  friend void protobuf_AssignDesc_lkpProto_2eproto();
  friend void protobuf_ShutdownFile_lkpProto_2eproto();

  void InitAsDefaultInstance();
  static Return_NodeInfo* default_instance_;
};
// -------------------------------------------------------------------

class Return : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lkpMessage.Return) */ {
 public:
  Return();
  virtual ~Return();

  Return(const Return& from);

  inline Return& operator=(const Return& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Return& default_instance();

  void Swap(Return* other);

  // implements Message ----------------------------------------------

  inline Return* New() const { return New(NULL); }

  Return* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Return& from);
  void MergeFrom(const Return& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Return* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Return_NodeInfo NodeInfo;

  // accessors -------------------------------------------------------

  // optional uint32 client_num = 1;
  void clear_client_num();
  static const int kClientNumFieldNumber = 1;
  ::google::protobuf::uint32 client_num() const;
  void set_client_num(::google::protobuf::uint32 value);

  // optional uint32 client_ok_num = 2;
  void clear_client_ok_num();
  static const int kClientOkNumFieldNumber = 2;
  ::google::protobuf::uint32 client_ok_num() const;
  void set_client_ok_num(::google::protobuf::uint32 value);

  // optional .lkpMessage.commandID command = 3;
  void clear_command();
  static const int kCommandFieldNumber = 3;
  ::lkpMessage::commandID command() const;
  void set_command(::lkpMessage::commandID value);

  // repeated .lkpMessage.Return.NodeInfo node_info = 4;
  int node_info_size() const;
  void clear_node_info();
  static const int kNodeInfoFieldNumber = 4;
  const ::lkpMessage::Return_NodeInfo& node_info(int index) const;
  ::lkpMessage::Return_NodeInfo* mutable_node_info(int index);
  ::lkpMessage::Return_NodeInfo* add_node_info();
  ::google::protobuf::RepeatedPtrField< ::lkpMessage::Return_NodeInfo >*
      mutable_node_info();
  const ::google::protobuf::RepeatedPtrField< ::lkpMessage::Return_NodeInfo >&
      node_info() const;

  // @@protoc_insertion_point(class_scope:lkpMessage.Return)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::uint32 client_num_;
  ::google::protobuf::uint32 client_ok_num_;
  ::google::protobuf::RepeatedPtrField< ::lkpMessage::Return_NodeInfo > node_info_;
  int command_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_lkpProto_2eproto();
  friend void protobuf_AssignDesc_lkpProto_2eproto();
  friend void protobuf_ShutdownFile_lkpProto_2eproto();

  void InitAsDefaultInstance();
  static Return* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Command

// optional .lkpMessage.commandID command = 1;
inline void Command::clear_command() {
  command_ = 0;
}
inline ::lkpMessage::commandID Command::command() const {
  // @@protoc_insertion_point(field_get:lkpMessage.Command.command)
  return static_cast< ::lkpMessage::commandID >(command_);
}
inline void Command::set_command(::lkpMessage::commandID value) {
  
  command_ = value;
  // @@protoc_insertion_point(field_set:lkpMessage.Command.command)
}

// optional bool send_to_all = 2;
inline void Command::clear_send_to_all() {
  send_to_all_ = false;
}
inline bool Command::send_to_all() const {
  // @@protoc_insertion_point(field_get:lkpMessage.Command.send_to_all)
  return send_to_all_;
}
inline void Command::set_send_to_all(bool value) {
  
  send_to_all_ = value;
  // @@protoc_insertion_point(field_set:lkpMessage.Command.send_to_all)
}

// optional string testcase = 3;
inline void Command::clear_testcase() {
  testcase_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Command::testcase() const {
  // @@protoc_insertion_point(field_get:lkpMessage.Command.testcase)
  return testcase_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Command::set_testcase(const ::std::string& value) {
  
  testcase_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:lkpMessage.Command.testcase)
}
inline void Command::set_testcase(const char* value) {
  
  testcase_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:lkpMessage.Command.testcase)
}
inline void Command::set_testcase(const char* value, size_t size) {
  
  testcase_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:lkpMessage.Command.testcase)
}
inline ::std::string* Command::mutable_testcase() {
  
  // @@protoc_insertion_point(field_mutable:lkpMessage.Command.testcase)
  return testcase_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Command::release_testcase() {
  // @@protoc_insertion_point(field_release:lkpMessage.Command.testcase)
  
  return testcase_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Command::set_allocated_testcase(::std::string* testcase) {
  if (testcase != NULL) {
    
  } else {
    
  }
  testcase_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), testcase);
  // @@protoc_insertion_point(field_set_allocated:lkpMessage.Command.testcase)
}

// optional uint32 docker_num = 4;
inline void Command::clear_docker_num() {
  docker_num_ = 0u;
}
inline ::google::protobuf::uint32 Command::docker_num() const {
  // @@protoc_insertion_point(field_get:lkpMessage.Command.docker_num)
  return docker_num_;
}
inline void Command::set_docker_num(::google::protobuf::uint32 value) {
  
  docker_num_ = value;
  // @@protoc_insertion_point(field_set:lkpMessage.Command.docker_num)
}

// optional uint32 tesetcase_len = 5;
inline void Command::clear_tesetcase_len() {
  tesetcase_len_ = 0u;
}
inline ::google::protobuf::uint32 Command::tesetcase_len() const {
  // @@protoc_insertion_point(field_get:lkpMessage.Command.tesetcase_len)
  return tesetcase_len_;
}
inline void Command::set_tesetcase_len(::google::protobuf::uint32 value) {
  
  tesetcase_len_ = value;
  // @@protoc_insertion_point(field_set:lkpMessage.Command.tesetcase_len)
}

// optional uint32 node_id = 6;
inline void Command::clear_node_id() {
  node_id_ = 0u;
}
inline ::google::protobuf::uint32 Command::node_id() const {
  // @@protoc_insertion_point(field_get:lkpMessage.Command.node_id)
  return node_id_;
}
inline void Command::set_node_id(::google::protobuf::uint32 value) {
  
  node_id_ = value;
  // @@protoc_insertion_point(field_set:lkpMessage.Command.node_id)
}

// -------------------------------------------------------------------

// File

// optional .lkpMessage.File.filetype file_type = 1;
inline void File::clear_file_type() {
  file_type_ = 0;
}
inline ::lkpMessage::File_filetype File::file_type() const {
  // @@protoc_insertion_point(field_get:lkpMessage.File.file_type)
  return static_cast< ::lkpMessage::File_filetype >(file_type_);
}
inline void File::set_file_type(::lkpMessage::File_filetype value) {
  
  file_type_ = value;
  // @@protoc_insertion_point(field_set:lkpMessage.File.file_type)
}

// optional string file_name = 2;
inline void File::clear_file_name() {
  file_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& File::file_name() const {
  // @@protoc_insertion_point(field_get:lkpMessage.File.file_name)
  return file_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void File::set_file_name(const ::std::string& value) {
  
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:lkpMessage.File.file_name)
}
inline void File::set_file_name(const char* value) {
  
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:lkpMessage.File.file_name)
}
inline void File::set_file_name(const char* value, size_t size) {
  
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:lkpMessage.File.file_name)
}
inline ::std::string* File::mutable_file_name() {
  
  // @@protoc_insertion_point(field_mutable:lkpMessage.File.file_name)
  return file_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* File::release_file_name() {
  // @@protoc_insertion_point(field_release:lkpMessage.File.file_name)
  
  return file_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void File::set_allocated_file_name(::std::string* file_name) {
  if (file_name != NULL) {
    
  } else {
    
  }
  file_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file_name);
  // @@protoc_insertion_point(field_set_allocated:lkpMessage.File.file_name)
}

// optional uint32 patch_len = 3;
inline void File::clear_patch_len() {
  patch_len_ = 0u;
}
inline ::google::protobuf::uint32 File::patch_len() const {
  // @@protoc_insertion_point(field_get:lkpMessage.File.patch_len)
  return patch_len_;
}
inline void File::set_patch_len(::google::protobuf::uint32 value) {
  
  patch_len_ = value;
  // @@protoc_insertion_point(field_set:lkpMessage.File.patch_len)
}

// optional uint32 file_size = 4;
inline void File::clear_file_size() {
  file_size_ = 0u;
}
inline ::google::protobuf::uint32 File::file_size() const {
  // @@protoc_insertion_point(field_get:lkpMessage.File.file_size)
  return file_size_;
}
inline void File::set_file_size(::google::protobuf::uint32 value) {
  
  file_size_ = value;
  // @@protoc_insertion_point(field_set:lkpMessage.File.file_size)
}

// optional bool first_patch = 5;
inline void File::clear_first_patch() {
  first_patch_ = false;
}
inline bool File::first_patch() const {
  // @@protoc_insertion_point(field_get:lkpMessage.File.first_patch)
  return first_patch_;
}
inline void File::set_first_patch(bool value) {
  
  first_patch_ = value;
  // @@protoc_insertion_point(field_set:lkpMessage.File.first_patch)
}

// optional bytes content = 6;
inline void File::clear_content() {
  content_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& File::content() const {
  // @@protoc_insertion_point(field_get:lkpMessage.File.content)
  return content_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void File::set_content(const ::std::string& value) {
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:lkpMessage.File.content)
}
inline void File::set_content(const char* value) {
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:lkpMessage.File.content)
}
inline void File::set_content(const void* value, size_t size) {
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:lkpMessage.File.content)
}
inline ::std::string* File::mutable_content() {
  
  // @@protoc_insertion_point(field_mutable:lkpMessage.File.content)
  return content_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* File::release_content() {
  // @@protoc_insertion_point(field_release:lkpMessage.File.content)
  
  return content_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void File::set_allocated_content(::std::string* content) {
  if (content != NULL) {
    
  } else {
    
  }
  content_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), content);
  // @@protoc_insertion_point(field_set_allocated:lkpMessage.File.content)
}

// optional uint32 node_id = 7;
inline void File::clear_node_id() {
  node_id_ = 0u;
}
inline ::google::protobuf::uint32 File::node_id() const {
  // @@protoc_insertion_point(field_get:lkpMessage.File.node_id)
  return node_id_;
}
inline void File::set_node_id(::google::protobuf::uint32 value) {
  
  node_id_ = value;
  // @@protoc_insertion_point(field_set:lkpMessage.File.node_id)
}

// -------------------------------------------------------------------

// CommandACK

// optional bool status = 1;
inline void CommandACK::clear_status() {
  status_ = false;
}
inline bool CommandACK::status() const {
  // @@protoc_insertion_point(field_get:lkpMessage.CommandACK.status)
  return status_;
}
inline void CommandACK::set_status(bool value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:lkpMessage.CommandACK.status)
}

// optional .lkpMessage.commandID command = 2;
inline void CommandACK::clear_command() {
  command_ = 0;
}
inline ::lkpMessage::commandID CommandACK::command() const {
  // @@protoc_insertion_point(field_get:lkpMessage.CommandACK.command)
  return static_cast< ::lkpMessage::commandID >(command_);
}
inline void CommandACK::set_command(::lkpMessage::commandID value) {
  
  command_ = value;
  // @@protoc_insertion_point(field_set:lkpMessage.CommandACK.command)
}

// optional string ack_message = 3;
inline void CommandACK::clear_ack_message() {
  ack_message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CommandACK::ack_message() const {
  // @@protoc_insertion_point(field_get:lkpMessage.CommandACK.ack_message)
  return ack_message_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CommandACK::set_ack_message(const ::std::string& value) {
  
  ack_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:lkpMessage.CommandACK.ack_message)
}
inline void CommandACK::set_ack_message(const char* value) {
  
  ack_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:lkpMessage.CommandACK.ack_message)
}
inline void CommandACK::set_ack_message(const char* value, size_t size) {
  
  ack_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:lkpMessage.CommandACK.ack_message)
}
inline ::std::string* CommandACK::mutable_ack_message() {
  
  // @@protoc_insertion_point(field_mutable:lkpMessage.CommandACK.ack_message)
  return ack_message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CommandACK::release_ack_message() {
  // @@protoc_insertion_point(field_release:lkpMessage.CommandACK.ack_message)
  
  return ack_message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CommandACK::set_allocated_ack_message(::std::string* ack_message) {
  if (ack_message != NULL) {
    
  } else {
    
  }
  ack_message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ack_message);
  // @@protoc_insertion_point(field_set_allocated:lkpMessage.CommandACK.ack_message)
}

// -------------------------------------------------------------------

// HeartBeat

// optional bool status = 1;
inline void HeartBeat::clear_status() {
  status_ = false;
}
inline bool HeartBeat::status() const {
  // @@protoc_insertion_point(field_get:lkpMessage.HeartBeat.status)
  return status_;
}
inline void HeartBeat::set_status(bool value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:lkpMessage.HeartBeat.status)
}

// -------------------------------------------------------------------

// PushACK

// optional bool status = 1;
inline void PushACK::clear_status() {
  status_ = false;
}
inline bool PushACK::status() const {
  // @@protoc_insertion_point(field_get:lkpMessage.PushACK.status)
  return status_;
}
inline void PushACK::set_status(bool value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:lkpMessage.PushACK.status)
}

// optional string ack_message = 2;
inline void PushACK::clear_ack_message() {
  ack_message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PushACK::ack_message() const {
  // @@protoc_insertion_point(field_get:lkpMessage.PushACK.ack_message)
  return ack_message_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PushACK::set_ack_message(const ::std::string& value) {
  
  ack_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:lkpMessage.PushACK.ack_message)
}
inline void PushACK::set_ack_message(const char* value) {
  
  ack_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:lkpMessage.PushACK.ack_message)
}
inline void PushACK::set_ack_message(const char* value, size_t size) {
  
  ack_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:lkpMessage.PushACK.ack_message)
}
inline ::std::string* PushACK::mutable_ack_message() {
  
  // @@protoc_insertion_point(field_mutable:lkpMessage.PushACK.ack_message)
  return ack_message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PushACK::release_ack_message() {
  // @@protoc_insertion_point(field_release:lkpMessage.PushACK.ack_message)
  
  return ack_message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PushACK::set_allocated_ack_message(::std::string* ack_message) {
  if (ack_message != NULL) {
    
  } else {
    
  }
  ack_message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ack_message);
  // @@protoc_insertion_point(field_set_allocated:lkpMessage.PushACK.ack_message)
}

// optional uint32 node_id = 3;
inline void PushACK::clear_node_id() {
  node_id_ = 0u;
}
inline ::google::protobuf::uint32 PushACK::node_id() const {
  // @@protoc_insertion_point(field_get:lkpMessage.PushACK.node_id)
  return node_id_;
}
inline void PushACK::set_node_id(::google::protobuf::uint32 value) {
  
  node_id_ = value;
  // @@protoc_insertion_point(field_set:lkpMessage.PushACK.node_id)
}

// -------------------------------------------------------------------

// Return_NodeInfo

// optional uint32 node_id = 1;
inline void Return_NodeInfo::clear_node_id() {
  node_id_ = 0u;
}
inline ::google::protobuf::uint32 Return_NodeInfo::node_id() const {
  // @@protoc_insertion_point(field_get:lkpMessage.Return.NodeInfo.node_id)
  return node_id_;
}
inline void Return_NodeInfo::set_node_id(::google::protobuf::uint32 value) {
  
  node_id_ = value;
  // @@protoc_insertion_point(field_set:lkpMessage.Return.NodeInfo.node_id)
}

// optional string node_msg = 2;
inline void Return_NodeInfo::clear_node_msg() {
  node_msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Return_NodeInfo::node_msg() const {
  // @@protoc_insertion_point(field_get:lkpMessage.Return.NodeInfo.node_msg)
  return node_msg_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Return_NodeInfo::set_node_msg(const ::std::string& value) {
  
  node_msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:lkpMessage.Return.NodeInfo.node_msg)
}
inline void Return_NodeInfo::set_node_msg(const char* value) {
  
  node_msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:lkpMessage.Return.NodeInfo.node_msg)
}
inline void Return_NodeInfo::set_node_msg(const char* value, size_t size) {
  
  node_msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:lkpMessage.Return.NodeInfo.node_msg)
}
inline ::std::string* Return_NodeInfo::mutable_node_msg() {
  
  // @@protoc_insertion_point(field_mutable:lkpMessage.Return.NodeInfo.node_msg)
  return node_msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Return_NodeInfo::release_node_msg() {
  // @@protoc_insertion_point(field_release:lkpMessage.Return.NodeInfo.node_msg)
  
  return node_msg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Return_NodeInfo::set_allocated_node_msg(::std::string* node_msg) {
  if (node_msg != NULL) {
    
  } else {
    
  }
  node_msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), node_msg);
  // @@protoc_insertion_point(field_set_allocated:lkpMessage.Return.NodeInfo.node_msg)
}

// -------------------------------------------------------------------

// Return

// optional uint32 client_num = 1;
inline void Return::clear_client_num() {
  client_num_ = 0u;
}
inline ::google::protobuf::uint32 Return::client_num() const {
  // @@protoc_insertion_point(field_get:lkpMessage.Return.client_num)
  return client_num_;
}
inline void Return::set_client_num(::google::protobuf::uint32 value) {
  
  client_num_ = value;
  // @@protoc_insertion_point(field_set:lkpMessage.Return.client_num)
}

// optional uint32 client_ok_num = 2;
inline void Return::clear_client_ok_num() {
  client_ok_num_ = 0u;
}
inline ::google::protobuf::uint32 Return::client_ok_num() const {
  // @@protoc_insertion_point(field_get:lkpMessage.Return.client_ok_num)
  return client_ok_num_;
}
inline void Return::set_client_ok_num(::google::protobuf::uint32 value) {
  
  client_ok_num_ = value;
  // @@protoc_insertion_point(field_set:lkpMessage.Return.client_ok_num)
}

// optional .lkpMessage.commandID command = 3;
inline void Return::clear_command() {
  command_ = 0;
}
inline ::lkpMessage::commandID Return::command() const {
  // @@protoc_insertion_point(field_get:lkpMessage.Return.command)
  return static_cast< ::lkpMessage::commandID >(command_);
}
inline void Return::set_command(::lkpMessage::commandID value) {
  
  command_ = value;
  // @@protoc_insertion_point(field_set:lkpMessage.Return.command)
}

// repeated .lkpMessage.Return.NodeInfo node_info = 4;
inline int Return::node_info_size() const {
  return node_info_.size();
}
inline void Return::clear_node_info() {
  node_info_.Clear();
}
inline const ::lkpMessage::Return_NodeInfo& Return::node_info(int index) const {
  // @@protoc_insertion_point(field_get:lkpMessage.Return.node_info)
  return node_info_.Get(index);
}
inline ::lkpMessage::Return_NodeInfo* Return::mutable_node_info(int index) {
  // @@protoc_insertion_point(field_mutable:lkpMessage.Return.node_info)
  return node_info_.Mutable(index);
}
inline ::lkpMessage::Return_NodeInfo* Return::add_node_info() {
  // @@protoc_insertion_point(field_add:lkpMessage.Return.node_info)
  return node_info_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::lkpMessage::Return_NodeInfo >*
Return::mutable_node_info() {
  // @@protoc_insertion_point(field_mutable_list:lkpMessage.Return.node_info)
  return &node_info_;
}
inline const ::google::protobuf::RepeatedPtrField< ::lkpMessage::Return_NodeInfo >&
Return::node_info() const {
  // @@protoc_insertion_point(field_list:lkpMessage.Return.node_info)
  return node_info_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace lkpMessage

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::lkpMessage::File_filetype> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::lkpMessage::File_filetype>() {
  return ::lkpMessage::File_filetype_descriptor();
}
template <> struct is_proto_enum< ::lkpMessage::commandID> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::lkpMessage::commandID>() {
  return ::lkpMessage::commandID_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_lkpProto_2eproto__INCLUDED
